# v2.5 上下文翻译修复说明

## 🎯 最终设计：滚动窗口上下文

**版本**: v2.5.6  
**更新日期**: 2025-11-15  
**设计原则**: 每批次使用前一批次作为上下文（滚动窗口），批次串行翻译

### 核心概念

- ✅ **批次内上下文**：批次的3张图片之间可以互相参考（高质量翻译器自动处理）
- ✅ **批次间上下文**：每批次使用前一批次的翻译结果作为上下文
- ✅ **滚动窗口**：批次0→批次1→批次2，形成连续的上下文链
- ✅ **顺序保证**：使用条件变量确保批次按顺序保存上下文

### 工作原理

**批次大小=3时的上下文链**：
```
批次0（图片1-3）：无前置上下文 + 批次内3图互参
                 ↓ 保存批次0翻译结果
批次1（图片4-6）：使用批次0作为上下文 + 批次内3图互参
                 ↓ 保存批次1翻译结果  
批次2（图片7-9）：使用批次1作为上下文 + 批次内3图互参
                 ↓ 保存批次2翻译结果
批次3（图片10-12）：使用批次2作为上下文 + 批次内3图互参
```

**双重上下文机制**：
1. **批次内上下文**：高质量翻译器同时看到批次的3张图，自然理解图片间关系
2. **批次间上下文**：每批次参考前一批次的翻译结果，保持连续性

### 实现代码

```python
# 流水线初始化
page_counter = {'count': 0}  # 批次计数器
batch_context_lock = asyncio.Lock()  # 批次上下文保存锁
batch_save_condition = asyncio.Condition(batch_context_lock)  # 条件变量，确保按顺序保存
next_save_batch_index = {'index': 0}  # 下一个应该保存的批次索引

# _process_translation_batch方法
async def _process_translation_batch(
    self, batch_buffer, translate_queue, line2_semaphore, 
    page_counter, batch_save_condition, next_save_batch_index
):
    """处理翻译批次 - 滚动窗口：每批次使用前一批次作为上下文"""
    
    # 获取批次索引
    current_batch_index = page_counter['count']
    page_counter['count'] += 1
    
    # ⚠️ 关键修复：在开始翻译前，等待前一批次保存好上下文
    if current_batch_index > 0:
        async with batch_save_condition:
            # 等待前一批次（current_batch_index-1）保存完成
            while next_save_batch_index['index'] < current_batch_index:
                await batch_save_condition.wait()
            logger.info(f"批次{current_batch_index}获取到批次{current_batch_index-1}的上下文")
    
    logger.info(f"Line2: 开始翻译批次{current_batch_index} - 使用批次{current_batch_index-1}作为上下文")
    
    # 设置高质量翻译批量数据
    sample_ctx.high_quality_batch_data = batch_data
    sample_ctx.high_quality_batch_size = len(batch_buffer)
    
    # 整个批次统一翻译（传递page_index以启用前一批次上下文）
    translated_texts = await self._batch_translate_texts(
        all_texts, sample_config, sample_ctx,
        page_index=current_batch_index  # ← 使用前一批次作为上下文
    )
    
    # 按顺序保存批次翻译结果（用于下一批次的上下文）
    async with batch_save_condition:
        # 等待轮到自己保存（必须按批次顺序）
        while next_save_batch_index['index'] != current_batch_index:
            await batch_save_condition.wait()
        
        # 将整个批次的翻译结果打包为一个字典
        batch_translations = {r.text: r.translation for r in all_text_regions if r.translation}
        self.all_page_translations.append(batch_translations)
        
        # 通知下一个批次
        next_save_batch_index['index'] += 1
        batch_save_condition.notify_all()
```

### 关键问题与修复

**❌ 问题：并发导致上下文缺失**

初始实现时，批次可以并发启动翻译，但上下文在翻译完成后才保存：
```
17:55:44.081 - 批次0开始翻译（无上下文，正常）
17:55:44.357 - 批次1开始翻译（期望使用批次0上下文）← 但批次0还在翻译中！
17:56:33.663 - 批次0保存上下文 ← 太晚了，批次1已经开始了
```

**✅ 修复：翻译前等待前批次保存**

添加等待机制，确保批次在开始翻译前，前一批次已保存上下文：
```python
if current_batch_index > 0:
    # 等待前一批次保存完成
    while next_save_batch_index['index'] < current_batch_index:
        await batch_save_condition.wait()
```

**新的执行流程**：
```
批次0: 开始翻译 → 完成 → 保存上下文 → 通知批次1
批次1: 等待... → 获取批次0上下文 → 开始翻译 → 完成 → 保存 → 通知批次2
批次2: 等待... → 获取批次1上下文 → 开始翻译
```

### 优点

1. **连续上下文**：批次间形成连续的翻译上下文链
2. **并发安全**：条件变量确保批次按顺序保存，避免上下文错乱
3. **双重上下文**：批次内+批次间双重上下文机制
4. **高效翻译**：OpenAI一次性看到批次内所有图片+前一批次翻译结果
5. **时序正确**：批次串行翻译，确保能获取到前一批次的上下文

---

## � 历史问题记录

### ❌ 问题1：跨批次上下文并发冲突（已废弃）

**原症状**：流水线模式下，所有批次都显示"无历史上下文"

```python
# 原代码 - 错误
translated_texts = await self._batch_translate_texts(
    all_texts, sample_config, sample_ctx  # ← 缺少page_index！
)
```

而`_batch_translate_texts`需要`page_index`来构建上下文历史：

```python
async def _batch_translate_texts(
    self, texts, config, ctx, 
    page_index: int = None,  # ← 需要这个参数！
    ...
):
    if self.context_size > 0:
        # 使用page_index构建历史上下文
        prev_ctx = self._build_prev_context(
            current_page_index=page_index,
            ...
        )
```

## ✅ 修复方案

### 1. 添加页面计数器

在流水线初始化时创建：

```python
# 上下文追踪（用于context-aware翻译）
page_counter = {'count': 0}  # 使用字典以便在闭包中修改
```

### 2. 修改方法签名

```python
# 修改前
async def _process_translation_batch(self, batch_buffer, translate_queue, line2_semaphore):

# 修改后
async def _process_translation_batch(self, batch_buffer, translate_queue, line2_semaphore, page_counter):
```

### 3. 传递批次索引（每批次作为独立上下文单位）

```python
# 获取当前批次索引（每个批次作为独立上下文单位）
current_batch_index = page_counter['count']
# 递增批次计数器
page_counter['count'] += 1

logger.info(f"Line2: 使用批次索引 {current_batch_index} (第{current_batch_index}批，{len(batch_buffer)}张图片) 进行上下文翻译")

# 批量翻译（传递page_index以启用上下文）
translated_texts = await self._batch_translate_texts(
    all_texts, sample_config, sample_ctx,
    page_index=current_batch_index  # ← 关键修复！
)
```

**重要变更**：
- **每个批次作为独立上下文单位**
- `page_index`代表"批次序号"（第0批、第1批、第2批...）
- 每次递增 = 1（批次递增）

### 4. 更新所有调用点

修改Line2 worker中的两处调用：

```python
# 调用点1：批量满时
if len(batch_buffer) >= self.pipeline_translation_batch_size:
    await self._process_translation_batch(batch_buffer, translate_queue, line2_semaphore, page_counter)
    
# 调用点2：超时后处理剩余
if batch_buffer:
    await self._process_translation_batch(batch_buffer, translate_queue, line2_semaphore, page_counter)
```

## 🎯 预期效果

修复后，应该看到：

### 第1批（图片1-3，batch_index=0）
```
Line2: 开始批量翻译 3 个项目
Line2: 使用批次索引 0 (第0批，3张图片) 进行上下文翻译
# 第一批没有历史上下文（batch_index=0时没有历史）
No post-translation replacements made.
Line2: 完成批量翻译 3 个项目
# page_counter['count'] 从 0 -> 1
```

### 第2批（图片4-6，batch_index=1）
```
Line2: 开始批量翻译 3 个项目
Line2: 使用批次索引 1 (第1批，3张图片) 进行上下文翻译
Context-aware translation enabled with 3 pages of history using translation results  ← 上下文启用！
No post-translation replacements made.
Line2: 完成批量翻译 3 个项目
# page_counter['count'] 从 1 -> 2
```

### 第3批（图片7-9，batch_index=2）
```
Line2: 开始批量翻译 3 个项目
Line2: 使用批次索引 2 (第2批，3张图片) 进行上下文翻译
Context-aware translation enabled with 3 pages of history using translation results  ← 持续使用上下文
...
# page_counter['count'] 从 2 -> 3
```

### 最后一批（不满3张，比如只有2张）
```
Line2: 超时后处理剩余批次，大小: 2
Line2: 开始批量翻译 2 个项目
Line2: 使用批次索引 5 (第5批，2张图片) 进行上下文翻译
# page_counter['count'] 从 5 -> 6
```

## 📊 上下文工作原理

### 批次索引追踪（每批次独立）

**`page_index`含义**：批次序号（第几批）

**打包大小=3时**：
```
批次1（图片1-3）   → batch_index=0 → 第0批 → 无历史上下文
批次2（图片4-6）   → batch_index=1 → 第1批 → 使用第0批的翻译结果
批次3（图片7-9）   → batch_index=2 → 第2批 → 使用第0、1批的翻译结果
批次4（图片10-12） → batch_index=3 → 第3批 → 使用第0、1、2批的翻译结果
批次5（图片13-15） → batch_index=4 → 第4批 → 使用第1、2、3批的翻译结果（滚动窗口）
批次6（图片16-17） → batch_index=5 → 第5批 → 使用第2、3、4批的翻译结果（不满3张）
```

**关键点**：
- `page_index`代表**批次序号**（0、1、2、3...）
- 每次递增 = 1（批次递增）
- 每个批次作为独立的上下文单位

### 上下文历史

配置`context_size=3`时：
- 批次1（batch_index=0）：无历史上下文
- 批次2（batch_index=1）：参考第0批的翻译结果
- 批次3（batch_index=2）：参考第0、1批的翻译结果
- 批次4（batch_index=3）：参考第0、1、2批的翻译结果（最多3批）
- 批次5（batch_index=4）：参考第1、2、3批的翻译结果（滚动窗口，保留最近3批）

## 🔧 验证方法

### 1. 启用debug日志

设置日志级别为DEBUG以查看详细信息：
```python
logger.setLevel(logging.DEBUG)
```

### 2. 查找关键日志

运行翻译后，搜索：
```
Line2: 使用页面索引 X 进行上下文翻译
Context-aware translation enabled with 3 pages of history
```

### 3. 确认上下文数量

对于17张图片，批量大小=3：
- 批次1：无上下文
- 批次2-6：应该都有"Context-aware translation enabled"

## 📝 注意事项

### 第一批无上下文是正常的

这是预期行为，因为：
- 第一批是整个翻译任务的开始
- 没有历史翻译结果可供参考
- 从第二批开始才能使用上下文

### 上下文适用范围

上下文翻译仅对以下翻译器有效：
- OpenAI
- Gemini
- OpenAI HQ
- Gemini HQ

其他翻译器不支持上下文功能。

---

## 🎯 验证方法

运行翻译后，检查日志中的关键信息：

### 批次0（首批，无前置上下文）
```
Line2: 开始翻译批次0 (3张图片) - 使用批次-1作为上下文
Line2: 已设置high_quality_batch_data，批次大小: 3
使用OpenAI高质量翻译模式处理3张图片
高质量翻译模式：正在打包 3 张图片并发送...
Line2: 保存批次0的 8 条翻译结果用于下一批次上下文  ← 保存给批次1使用
Line2: 完成批次0翻译 (3张图片)
```

### 批次1（等待批次0，然后使用其上下文）
```
Line2: 批次1等待批次0保存上下文...  ← 等待批次0完成
--- 批次0完成翻译和保存，通知批次1 ---
Line2: 批次1获取到批次0的上下文，开始翻译  ← 成功获取！
Line2: 开始翻译批次1 (3张图片) - 使用批次0作为上下文
Context-aware translation enabled with 3 pages of history  ← 启用批次0上下文！✅
[HQ历史上下文] 长度: XXX 字符  ← 显示批次0的翻译结果
Carrying X pages of context, Y sentences as translation reference
Line2: 保存批次1的 7 条翻译结果用于下一批次上下文  ← 保存给批次2使用
Line2: 完成批次1翻译 (3张图片)
```

### 批次2（等待批次1，然后使用其上下文）
```
Line2: 批次2等待批次1保存上下文...  ← 等待批次1完成
--- 批次1完成翻译和保存，通知批次2 ---
Line2: 批次2获取到批次1的上下文，开始翻译  ← 成功获取！
Line2: 开始翻译批次2 (3张图片) - 使用批次1作为上下文
Context-aware translation enabled with 3 pages of history  ← 启用批次1上下文！✅
[HQ历史上下文] 长度: XXX 字符  ← 显示批次1的翻译结果（不是批次0）
Line2: 保存批次2的 9 条翻译结果用于下一批次上下文
Line2: 完成批次2翻译 (3张图片)
```

**关键验证点**：
- ✅ 批次0：无上下文（正常）
- ✅ 批次1：显示"Context-aware translation enabled"，使用批次0
- ✅ 批次2：显示"Context-aware translation enabled"，使用批次1
- ✅ 每个批次都保存翻译结果供下一批次使用
- ✅ 高质量翻译模式启用
- ✅ 顺序保存确保无上下文错乱

---

**版本**: v2.5.6  
**更新日期**: 2025-11-15  
**状态**: ✅ 滚动窗口上下文设计已完成，并发上下文缺失问题已修复

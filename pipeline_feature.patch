diff --git a/manga_translator/manga_translator.py b/manga_translator/manga_translator.py
index eed71ef..c9d67de 100644
--- a/manga_translator/manga_translator.py
+++ b/manga_translator/manga_translator.py
@@ -313,6 +313,11 @@ class MangaTranslator:
         self.pipeline_line1_concurrency = _safe_int(params.get('pipeline_line1_concurrency', 2), 2)
         self.pipeline_line2_concurrency = _safe_int(params.get('pipeline_line2_concurrency', 3), 3)
         self.pipeline_line3_concurrency = _safe_int(params.get('pipeline_line3_concurrency', 1), 1)
+        self.pipeline_line4_concurrency = _safe_int(params.get('pipeline_line4_concurrency', 1), 1)
+        self.pipeline_translation_batch_size = _safe_int(
+            params.get('pipeline_translation_batch_size', self.high_quality_batch_size),
+            self.high_quality_batch_size
+        )
         
         # 验证batch_concurrent参数
         if self.batch_concurrent and self.batch_size < 2:
@@ -2740,10 +2745,12 @@ class MangaTranslator:
         """
         batch_size = batch_size or self.batch_size
         
-        # ✅ 如果启用了流水线并行模式，自动转发到pipeline_translate_batch
+        # ✅ 如果启用了四线流水线模式，使用并行处理工作流
         if self.pipeline_mode and len(images_with_configs) > 1:
-            logger.info("Pipeline mode enabled, using parallel processing workflow")
-            return await self.pipeline_translate_batch(images_with_configs, batch_size, image_names, save_info)
+            logger.info(f"启动四线流水线模式：{len(images_with_configs)} 张图片")
+            logger.info(f"并发设置 - Line1(检测+OCR):{self.pipeline_line1_concurrency}, Line2(翻译):{self.pipeline_line2_concurrency}, Line3(修复):{self.pipeline_line3_concurrency}, Line4(渲染+超分):{self.pipeline_line4_concurrency}")
+            logger.info(f"翻译打包大小: {self.pipeline_translation_batch_size}")
+            return await self._translate_batch_pipeline_4_lines(images_with_configs, save_info)
         
         batch_size = batch_size or self.batch_size
         
@@ -4587,3 +4594,423 @@ class MangaTranslator:
 
         logger.info(f"High quality translation completed: processed {len(results)} images")
         return results
+
+    async def _translate_batch_pipeline_4_lines(self, images_with_configs: List[tuple], save_info: dict = None) -> List[Context]:
+        """
+        四线流水线批量翻译实现
+        Line1: 检测+OCR (并发)
+        Line2: 翻译 (打包批量处理)
+        Line3: 修复/Inpainting (并发)
+        Line4: 渲染+超分 (并发)
+        """
+        import asyncio
+        from asyncio import Queue, Semaphore
+        import traceback
+        
+        total_images = len(images_with_configs)
+        logger.info(f"四线流水线启动：处理 {total_images} 张图片")
+        
+        # 创建队列和信号量
+        ocr_queue = Queue(maxsize=50)  # Line1 -> Line2
+        translate_queue = Queue(maxsize=50)  # Line2 -> Line3
+        inpaint_queue = Queue(maxsize=50)  # Line3 -> Line4
+        render_queue = Queue(maxsize=50)  # Line4 -> 结果
+        
+        # 并发控制信号量
+        line1_semaphore = Semaphore(self.pipeline_line1_concurrency)
+        line2_semaphore = Semaphore(self.pipeline_line2_concurrency)
+        line3_semaphore = Semaphore(self.pipeline_line3_concurrency)
+        line4_semaphore = Semaphore(self.pipeline_line4_concurrency)
+        
+        results = []
+        completed_count = 0
+        
+        async def line1_worker(image, config, index):
+            """Line1: 检测+OCR"""
+            async with line1_semaphore:
+                try:
+                    logger.info(f"Line1: 开始处理图片 {index+1}/{total_images}")
+                    
+                    # 设置图片上下文
+                    self._set_image_context(config, image)
+                    
+                    ctx = Context()
+                    ctx.input = image
+                    ctx.image_name = getattr(image, 'name', None)
+                    ctx.verbose = self.verbose
+                    ctx.save_quality = self.save_quality
+                    ctx.config = config
+
+                    # 上色处理
+                    if config.colorizer.colorizer.value != 'none':
+                        logger.debug(f"Line1: 上色处理 - 图片 {index+1}")
+                        ctx.img_colorized = await self._run_colorizer(config, ctx)
+                    else:
+                        ctx.img_colorized = ctx.input
+
+                    # 超分处理
+                    if config.upscale.upscale_ratio:
+                        logger.debug(f"Line1: 超分处理 - 图片 {index+1}")
+                        ctx.upscaled = await self._run_upscaling(config, ctx)
+                    else:
+                        ctx.upscaled = ctx.img_colorized
+
+                    ctx.img_rgb, ctx.img_alpha = load_image(ctx.upscaled)
+
+                    # 检测
+                    logger.debug(f"Line1: 检测处理 - 图片 {index+1}")
+                    ctx.textlines, ctx.mask_raw, ctx.mask = await self._run_detection(config, ctx)
+
+                    if not ctx.textlines:
+                        logger.info(f"Line1: 图片 {index+1} 未检测到文本，跳过后续处理")
+                        await render_queue.put((ctx, config, index, True))  # 直接跳到结果队列
+                        return
+
+                    # OCR
+                    logger.debug(f"Line1: OCR处理 - 图片 {index+1}")
+                    ctx.textlines = await self._run_ocr(config, ctx)
+
+                    if not ctx.textlines:
+                        logger.info(f"Line1: 图片 {index+1} OCR未识别到文本，跳过后续处理")
+                        await render_queue.put((ctx, config, index, True))
+                        return
+
+                    # 文本行合并
+                    logger.debug(f"Line1: 文本行合并 - 图片 {index+1}")
+                    ctx.text_regions = await self._run_textline_merge(config, ctx)
+
+                    if not ctx.text_regions:
+                        logger.info(f"Line1: 图片 {index+1} 文本合并后无区域，跳过后续处理")
+                        await render_queue.put((ctx, config, index, True))
+                        return
+
+                    logger.info(f"Line1: 完成处理图片 {index+1}/{total_images}，检测到 {len(ctx.text_regions)} 个文本区域")
+                    await ocr_queue.put((ctx, config, index))
+                    
+                except Exception as e:
+                    logger.error(f"Line1: 处理图片 {index+1} 时出错: {e}")
+                    logger.error(f"Line1: 错误详情: {traceback.format_exc()}")
+                    # 创建失败的context
+                    ctx = Context()
+                    ctx.input = image
+                    ctx.image_name = getattr(image, 'name', None)
+                    ctx.result = image  # 返回原图
+                    await render_queue.put((ctx, config, index, True))
+
+        async def line2_worker():
+            """Line2: 翻译（批量处理）"""
+            batch_buffer = []
+            
+            while True:
+                try:
+                    # 收集批量翻译的项目
+                    try:
+                        # 超时等待，避免无限阻塞
+                        item = await asyncio.wait_for(ocr_queue.get(), timeout=2.0)
+                        batch_buffer.append(item)
+                        
+                        # 检查是否达到批量大小或队列为空
+                        if len(batch_buffer) >= self.pipeline_translation_batch_size or ocr_queue.empty():
+                            await self._process_translation_batch(batch_buffer, translate_queue, line2_semaphore)
+                            batch_buffer = []
+                            
+                    except asyncio.TimeoutError:
+                        # 超时后处理剩余的批次
+                        if batch_buffer:
+                            await self._process_translation_batch(batch_buffer, translate_queue, line2_semaphore)
+                            batch_buffer = []
+                        # 检查是否所有任务都完成了
+                        if ocr_queue.empty() and all(task.done() for task in line1_tasks):
+                            break
+                            
+                except Exception as e:
+                    logger.error(f"Line2: 翻译工作进程出错: {e}")
+                    break
+            
+            # 处理最后的批次
+            if batch_buffer:
+                await self._process_translation_batch(batch_buffer, translate_queue, line2_semaphore)
+
+        async def line3_worker():
+            """Line3: 修复/Inpainting"""
+            while True:
+                try:
+                    item = await asyncio.wait_for(translate_queue.get(), timeout=5.0)
+                    if item is None:  # 结束信号
+                        break
+                        
+                    ctx, config, index = item
+                    
+                    async with line3_semaphore:
+                        try:
+                            logger.info(f"Line3: 开始修复处理图片 {index+1}/{total_images}")
+                            
+                            # 恢复图片上下文
+                            if hasattr(ctx, 'input'):
+                                from .utils.generic import get_image_md5
+                                image_md5 = get_image_md5(ctx.input)
+                                if not self._restore_image_context(image_md5):
+                                    self._set_image_context(config, ctx.input)
+
+                            # 掩码细化
+                            if ctx.mask is None:
+                                logger.debug(f"Line3: 掩码细化 - 图片 {index+1}")
+                                ctx.mask = await self._run_mask_refinement(config, ctx)
+
+                            # 修复/Inpainting
+                            logger.debug(f"Line3: 修复处理 - 图片 {index+1}")
+                            ctx.img_inpainted = await self._run_inpainting(config, ctx)
+
+                            # 保存修复后的图片
+                            if hasattr(ctx, 'image_name') and ctx.image_name and ctx.img_inpainted is not None:
+                                self._save_inpainted_image(ctx.image_name, ctx.img_inpainted)
+
+                            logger.info(f"Line3: 完成修复处理图片 {index+1}/{total_images}")
+                            await inpaint_queue.put((ctx, config, index))
+                            
+                        except Exception as e:
+                            logger.error(f"Line3: 处理图片 {index+1} 时出错: {e}")
+                            logger.error(f"Line3: 错误详情: {traceback.format_exc()}")
+                            # 跳过修复，使用原图
+                            ctx.img_inpainted = ctx.img_rgb
+                            await inpaint_queue.put((ctx, config, index))
+                            
+                except asyncio.TimeoutError:
+                    # 检查是否所有前置任务都完成了
+                    if translate_queue.empty() and all(task.done() for task in line2_tasks):
+                        break
+                except Exception as e:
+                    logger.error(f"Line3: 工作进程出错: {e}")
+                    break
+
+        async def line4_worker():
+            """Line4: 渲染+超分"""
+            while True:
+                try:
+                    item = await asyncio.wait_for(inpaint_queue.get(), timeout=5.0)
+                    if item is None:  # 结束信号
+                        break
+                        
+                    ctx, config, index = item
+                    
+                    async with line4_semaphore:
+                        try:
+                            logger.info(f"Line4: 开始渲染处理图片 {index+1}/{total_images}")
+                            
+                            # 恢复图片上下文
+                            if hasattr(ctx, 'input'):
+                                from .utils.generic import get_image_md5
+                                image_md5 = get_image_md5(ctx.input)
+                                if not self._restore_image_context(image_md5):
+                                    self._set_image_context(config, ctx.input)
+
+                            # 渲染
+                            logger.debug(f"Line4: 渲染处理 - 图片 {index+1}")
+                            ctx.img_rendered = await self._run_text_rendering(config, ctx)
+
+                            # 生成最终结果
+                            ctx.result = dump_image(ctx.input, ctx.img_rendered, ctx.img_alpha)
+                            ctx = await self._revert_upscale(config, ctx)
+
+                            # 保存JSON
+                            if ctx.text_regions and hasattr(ctx, 'image_name') and ctx.image_name:
+                                self._save_text_to_file(ctx.image_name, ctx, config)
+
+                            logger.info(f"Line4: 完成渲染处理图片 {index+1}/{total_images}")
+                            await render_queue.put((ctx, config, index, False))
+                            
+                        except Exception as e:
+                            logger.error(f"Line4: 处理图片 {index+1} 时出错: {e}")
+                            logger.error(f"Line4: 错误详情: {traceback.format_exc()}")
+                            # 使用修复后的图片作为结果
+                            ctx.result = ctx.img_inpainted if hasattr(ctx, 'img_inpainted') else ctx.input
+                            await render_queue.put((ctx, config, index, False))
+                            
+                except asyncio.TimeoutError:
+                    # 检查是否所有前置任务都完成了
+                    if inpaint_queue.empty() and all(task.done() for task in line3_tasks):
+                        break
+                except Exception as e:
+                    logger.error(f"Line4: 工作进程出错: {e}")
+                    break
+
+        # 启动所有工作线程
+        line1_tasks = [asyncio.create_task(line1_worker(image, config, i)) 
+                       for i, (image, config) in enumerate(images_with_configs)]
+        
+        line2_tasks = [asyncio.create_task(line2_worker()) 
+                       for _ in range(self.pipeline_line2_concurrency)]
+        
+        line3_tasks = [asyncio.create_task(line3_worker()) 
+                       for _ in range(self.pipeline_line3_concurrency)]
+        
+        line4_tasks = [asyncio.create_task(line4_worker()) 
+                       for _ in range(self.pipeline_line4_concurrency)]
+
+        # 收集结果
+        result_contexts = [None] * total_images
+        
+        # 结果收集器
+        async def result_collector():
+            nonlocal completed_count
+            while completed_count < total_images:
+                try:
+                    ctx, config, index, skipped = await render_queue.get()
+                    result_contexts[index] = ctx
+                    completed_count += 1
+                    
+                    if skipped:
+                        logger.info(f"图片 {index+1}/{total_images} 处理完成（跳过翻译）")
+                    else:
+                        logger.info(f"图片 {index+1}/{total_images} 流水线处理完成")
+                    
+                    # 如果提供了save_info，保存图片
+                    if save_info and ctx.result:
+                        await self._save_pipeline_result(ctx, config, save_info)
+                    
+                except Exception as e:
+                    logger.error(f"结果收集器出错: {e}")
+
+        result_task = asyncio.create_task(result_collector())
+
+        # 真正的流水线执行：所有线程同时启动，通过队列协调
+        try:
+            # 等待所有任务完成（流水线模式）
+            all_tasks = line1_tasks + line2_tasks + line3_tasks + line4_tasks + [result_task]
+            await asyncio.gather(*all_tasks, return_exceptions=True)
+            
+        except Exception as e:
+            logger.error(f"流水线执行出错: {e}")
+        finally:
+            # 清理：发送结束信号给所有工作线程
+            logger.info("发送流水线结束信号...")
+            
+            # 给Line2发送结束信号（通过空的ocr_queue检测）
+            # Line2会在超时后自动检测line1_tasks完成状态
+            
+            # 给Line3发送结束信号
+            for _ in range(self.pipeline_line3_concurrency):
+                try:
+                    await asyncio.wait_for(translate_queue.put(None), timeout=1.0)
+                except:
+                    pass
+            
+            # 给Line4发送结束信号  
+            for _ in range(self.pipeline_line4_concurrency):
+                try:
+                    await asyncio.wait_for(inpaint_queue.put(None), timeout=1.0)
+                except:
+                    pass
+        logger.info("四线流水线处理完成")
+
+        # 过滤掉None结果并返回
+        final_results = [ctx for ctx in result_contexts if ctx is not None]
+        logger.info(f"四线流水线总计完成: {len(final_results)}/{total_images} 张图片")
+        
+        return final_results
+
+    async def _process_translation_batch(self, batch_buffer, translate_queue, line2_semaphore):
+        """处理翻译批次"""
+        if not batch_buffer:
+            return
+            
+        async with line2_semaphore:
+            try:
+                logger.info(f"Line2: 开始批量翻译 {len(batch_buffer)} 个项目")
+                
+                # 提取所有文本
+                all_texts = []
+                text_mapping = []  # (batch_index, region_index)
+                
+                for batch_idx, (ctx, config, image_idx) in enumerate(batch_buffer):
+                    if ctx.text_regions:
+                        for region_idx, region in enumerate(ctx.text_regions):
+                            all_texts.append(region.text)
+                            text_mapping.append((batch_idx, region_idx, image_idx))
+
+                if all_texts:
+                    # 使用第一个配置进行翻译
+                    sample_ctx, sample_config, _ = batch_buffer[0]
+                    
+                    # 批量翻译
+                    translated_texts = await self._batch_translate_texts(
+                        all_texts, sample_config, sample_ctx
+                    )
+                    
+                    # 将翻译结果分配回原始区域
+                    for text_idx, (batch_idx, region_idx, image_idx) in enumerate(text_mapping):
+                        if text_idx < len(translated_texts):
+                            ctx, config, _ = batch_buffer[batch_idx]
+                            if ctx.text_regions and region_idx < len(ctx.text_regions):
+                                region = ctx.text_regions[region_idx]
+                                region.translation = translated_texts[text_idx]
+                                region.target_lang = config.translator.target_lang
+                                region._alignment = config.render.alignment
+                                region._direction = config.render.direction
+
+                    # 应用后处理
+                    for ctx, config, image_idx in batch_buffer:
+                        if ctx.text_regions:
+                            ctx.text_regions = await self._apply_post_translation_processing(ctx, config)
+                
+                logger.info(f"Line2: 完成批量翻译 {len(batch_buffer)} 个项目")
+                
+                # 将处理好的项目放入下一个队列
+                for ctx, config, image_idx in batch_buffer:
+                    await translate_queue.put((ctx, config, image_idx))
+                    
+            except Exception as e:
+                logger.error(f"Line2: 批量翻译出错: {e}")
+                logger.error(f"Line2: 错误详情: {traceback.format_exc()}")
+                # 出错时仍然要将项目传递给下一阶段，避免流水线阻塞
+                for ctx, config, image_idx in batch_buffer:
+                    await translate_queue.put((ctx, config, image_idx))
+
+    async def _save_pipeline_result(self, ctx, config, save_info):
+        """保存流水线处理结果"""
+        try:
+            if not ctx.result:
+                return
+                
+            output_folder = save_info.get('output_folder')
+            input_folders = save_info.get('input_folders', set())
+            output_format = save_info.get('format')
+            overwrite = save_info.get('overwrite', True)
+
+            file_path = ctx.image_name
+            final_output_dir = output_folder
+            parent_dir = os.path.normpath(os.path.dirname(file_path))
+            
+            for folder in input_folders:
+                if parent_dir.startswith(folder):
+                    relative_path = os.path.relpath(parent_dir, folder)
+                    if relative_path == '.':
+                        final_output_dir = os.path.join(output_folder, os.path.basename(folder))
+                    else:
+                        final_output_dir = os.path.join(output_folder, os.path.basename(folder), relative_path)
+                    final_output_dir = os.path.normpath(final_output_dir)
+                    break
+            
+            os.makedirs(final_output_dir, exist_ok=True)
+
+            base_filename, _ = os.path.splitext(os.path.basename(file_path))
+            if output_format and output_format.strip() and output_format.lower() != 'none':
+                output_filename = f"{base_filename}.{output_format}"
+            else:
+                output_filename = os.path.basename(file_path)
+            
+            final_output_path = os.path.join(final_output_dir, output_filename)
+
+            if not overwrite and os.path.exists(final_output_path):
+                logger.info(f"  -> ⚠️ [PIPELINE] Skipping existing file: {os.path.basename(final_output_path)}")
+            else:
+                image_to_save = ctx.result
+                if final_output_path.lower().endswith(('.jpg', '.jpeg')) and image_to_save.mode in ('RGBA', 'LA'):
+                    image_to_save = image_to_save.convert('RGB')
+                
+                image_to_save.save(final_output_path, quality=self.save_quality)
+                logger.info(f"  -> ✅ [PIPELINE] Saved successfully: {os.path.basename(final_output_path)}")
+                self._update_translation_map(file_path, final_output_path)
+
+        except Exception as save_err:
+            logger.error(f"Error saving pipeline result for {os.path.basename(ctx.image_name) if hasattr(ctx, 'image_name') else 'Unknown'}: {save_err}")
